---
title: 虚拟化：内存虚拟化
date: 2025-03-18 14:21:00 +0800
categories: [操作系统]
tags: [虚拟化, 内存, 操作系统, OSTEP, 计算机]
---

为了便于使用，操作系统对内存进行了虚拟化。程序能看到的是**虚拟地址**，真实的**物理地址**是不可见的。操作系统对每一个进程提供了一种假象，那就是每个进程都认为自己在独享一块巨大的连续内存。如此一来，程序员在编写代码时，无需考虑究竟该将变量等数据存储在内存的哪个位置，极大地简化了操作。

但如此一来，便产生了新的问题：

1. OS如何将虚拟地址转换为物理地址
2. 如何在内存虚拟化的同时不影响性能
3. 如何保证当前进程不会访问其他进程的内存空间



# 地址转换

操作系统为物理内存提供了一种抽象：**地址空间。**一个进程的地址空间包含运行的程序的所有内存状态。为了将虚拟地址转换为物理地址，需要硬件的支持。所以CPU负责内存转换的部分统称为内存管理单元（MMU），其中含有两个寄存器——**基址寄存器**和**界限寄存器**。基址寄存器指向当前进程的物理地址开始处，界限寄存器保存当前进程的地址空间的大小。由于地址空间的地址是从零开始的，因此硬件收到虚拟地址后，物理地址 = 基址寄存器 + 虚拟地址，如果虚拟地址不合法（负值或超过了界限寄存器），则抛出异常交给OS处理。同时，由于每个进程所处的物理内存位置不同，因此在进程切换的时候，OS需要负责保存和恢复每个进程的基址寄存器和界限寄存器。

但由于一个进程的地址空间可能很大，而且堆和栈之间有大量的未被使用的内存，因此会导致物理内存的浪费，这被称为**内部碎片。**

**分段**解决了这一问题。

# 分段

将一个地址空间划分为几个不同的逻辑段，并为每个段都提供一堆基址/界限寄存器。例如，常见的地址空间可分为三段，代码、栈、堆，于是内存管理单元中就有三对基址/界限寄存器，分别用于不同的段。如此一来，一个进程的地址空间在物理内存中就不一定是连续存储的了，而是三段散布于不同位置。当硬件受到虚拟地址后，首先判断它位于哪个段，然后再根据该段的基址寄存器来定位到该段物理地址开头，然后计算该虚拟地址相对于段首偏移了多少，从而将其转换为物理地址。

为了消除内部碎片，使用了分段法，于是堆栈之间的空白区域就不用分配内存了。但有一个问题，使用分段法分配的堆有多大呢？是刚好存满，还是会有很多空白的没有使用的空间？如果是前者，那如果想要继续在堆里添加数据该怎么办，如果是后者，那这不还是会有内部碎片吗？其实分段不是完全消除内部碎片，而是尽可能缩小，分配的堆仍有一些空白空间。如果当前堆满了想要继续添加数据，此时如果堆段在内存中后续的地址空间未被其他段占用，操作系统可以通过改变堆段的结束地址直接扩展该段；如果后续地址已被占用，操作系统可能需要分配一个新的、更大的堆段，并复制旧堆数据到新位置（类似动态数组扩容）。

虽然解决了内部碎片问题，但是分段会导致内存中不同段之间有大量无法被使用的内存，这被称为**外部碎片**。更严重的问题是，如果一个堆是巨大且稀疏的，那堆段仍需完整地保存在内存中，仍然会有内存浪费。

于是有了**分页。**

# 分页

不同于分段法中不同的段的大小可能不同，分页法是将地址空间和物理内存都分为许多**大小相同**的页，并通过一种数据结构——页表——来保存每个虚拟页面在物理内存中对应的页。具体来说，虚拟地址可以分为虚拟页号和页内偏移量，根据页表来将虚拟页号转换为物理帧号，页内偏移量不变，两者拼接就是物理地址。

每个进程都有各自的页表，假设地址空间很大，一页很小，那页数会很多，页表中的项数也很多，所以一个页表会很大，而由于进程数通常很多，页表的数量也很多，于是仅仅存储页表就会占用大量内存。同时，每次内存引用，都会访问内存两次，一次是访问页表获取页表项，从而将虚拟地址转换为物理地址；一次是访问物理地址所在的内存，速度也很慢。

接下来需要解决**速度慢**和**页表过大**这两个问题。

## 如何提高分页机制的速度

**地址转换旁路缓冲寄存器（TLB）**，它就是频繁发生的虚拟到物理地址转换的硬件缓存，因此更好的名称应该是**地址转换缓存（address-translation cache）**。

对每次内存访问，硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表；反之，则访问页表获取转换映射，并用该转换映射更新TLB。

TLB未命中时，可能由硬件来处理，也可能由软件来处理。一条TLB项内容包含虚拟页号，物理页帧号，保护位，脏位，地址空间标识符等。

上下文切换时，上一个进程在TLB中的地址映射对于即将运行的进程是毫无意义的，此时要么清空TLB，要么在TLB中加入所谓的**地址空间标识符**，这样就能区分不同进程的地址映射，从而使得不同进程共享TLB。

TLB和其他缓存一样，还需要考虑缓存替换，即向TLB添加新项时，需要替换哪个旧项。一种常见策略是替换最近最少使用（LRU）的项，另一种策略是随机策略。

## 如何避免页表过大

方法1：使用更大的页。

问题在于大内存页会导致每页内的浪费，即内部碎片。



方法2：混合使用分页和分段。

依旧是将地址空间分为几个不同的逻辑段，再对每个段单独分页，各自拥有一个页表。这样，页表只需覆盖实际使用的段范围，而非整个虚拟地址空间。该方法的关键在于，界限寄存器保存了段中最大有效页的值，举例来说，如果代码段使用它的前三个页，则代码段页表将只有三个项分配给它，并且界限寄存器将被设置为3。

按需分配页表：

- 每个段（如代码段、数据段）可以有自己的页表，而非为整个虚拟地址空间维护一个统一的大页表。
- 若某个段未使用（如未初始化的堆），其对应的页表无需分配。

相较于线性页表，这种方法节省了大量内存，栈和堆之间未分配的页不再占用页表中的空间。但是如果有一个大且稀疏的堆，那依然会浪费内存，而且这种方法导致外部碎片再次出现。



方法3：多级页表。

将页表本身分成页大小的单元，如果整页的页表项无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为**页目录**的新结构。在一个简单的二级页表中，每页页表都在页目录中对应一个页目录项，每个页目录项拥有有效位和页帧号等。

多级页表的工作方式很简单：它只是让线性页表的一部分小时，并用页目录来记录页表中的哪些页被分配。

虚拟地址分为三部分：页目录索引-页表索引-偏移量。地址转换方法如下：

1. 首先通过页目录索引，经过简单计算找到页目录项地址，并获取页目录项。如果该项标记为有效，则获取该页目录项保存的物理帧号。
2. 物理帧号和页表索引经过计算，得到页表项的地址，获取页表项。
3. 得到页表项中的物理帧号，与偏移量结合，获得物理地址。

由于多级页表在TLB未命中时，需要多次访问内存，才能够从页表中获取地址映射，所以它需要更多的时间，这种方法是时间与空间的折中。

# 超越物理内存

如果地址空间很大，物理内存放不下该怎么办？为了支持更大的地址空间，操作系统需要把当前没有在用的那部分地址空间找个地方存储起来，一般会放在硬盘中，它更大但是更慢。现在的问题是，操作系统如何利用大而慢的设备，透明地提供巨大虚拟地址空间的假象？

为此，需要在硬盘上开辟一部分空间用于物理页的移入和移出，这样的空间被称为**交换空间（swap space）**，因为我们将内存中的页交换到其中，并在需要的时候又交换回去。操作系统需要记住给定页的硬盘地址。

然后需要在页表项中加入一位**存在位**，如果存在位为1，则表示该页存在于物理内存中，为0则存在于硬盘上。访问不在物理内存中的页，这种行为被称为**页错误/缺页（page fault）**。当发生内存引用时，硬件首先从虚拟地址获取虚拟页号，检查TLB是否命中，命中则取得物理地址并访问内存，未命中则在页表中获取地址映射，如果该页有效且位于物理内存中，则将页表项中存的物理帧号插入到TLB中，并重试该指令，如果发现该页不存在于物理内存中，则发生页错误，并唤起操作系统来处理，一段称为**页错误处理程序**的代码会执行。

发生页错误时，操作系统需要将页交换到内存中。页表项中保存了硬盘地址，OS会获取该地址，并将请求发送到硬盘，将页读取到内存，更新页表。如果内存已经满了，操作系统需要选择哪些页被替换，这被称为**页交换策略**。常见的交换策略有：FIFO，随机，LRU，近似LRU……此处细节就不再展开叙述。

# 总结

我们在程序中看到的所有地址都是虚拟地址，真实的物理地址则被操作系统隐藏，这提高了便利性，也使系统更加安全可靠。

在实现虚拟内存的过程中，我们遇到了一个又一个问题，但每个问题都被逐一解决：为了进行地址转换，我们引入了基址/界限寄存器等硬件；为了消除内部碎片，提出了分段的思想；为了消除外部碎片，提出了分页的思想；为了提高分页机制的速度，使虚拟内存成为可能，加入了TLB；为了减小页表，提出了多级页表的概念；为了解决物理内存不够用的问题，在硬盘上开辟交换空间……

内存虚拟化还有许多本文没有探讨的细节，仍然有许多问题等待我们发掘……







