---
title: 为什么需要锁？
date: 2025-03-28 08:00:00 +0800
categories: [操作系统]
tags: [并发，操作系统，OSTEP，锁，线程]
---

每个线程（thread）类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。

假设当前有两个线程，每个线程的工作只是简单地让全局计数器counter加1，循环10000次。

```c
for (int i = 0; i < 10000; i++) {
	counter = counter + 1;
}
```

正常来说，最后counter的值应该是20000，因为两个线程各自加了10000次。但实际上，counter的值不一定是20000，也可能是19988，19993等小于20000的值。为什么会这样？

首先来看上述代码的汇编代码

```assembly
mov 0x8000000, %eax
add $0x1, %eax
mov %eax, 0x8000000
```

counter变量位于地址0x8000000处，mov指令从该内存地址中取出counter并放入eax，然后，add指令给eax的值加1，最后，counter被存回内存中。

现在，设想上述两个线程开始执行上述代码。线程1首先取出counter放入eax（eax = 0)，随后加1（eax = 1)，此时，时钟中断产生，线程1的状态被保存起来，然后运行线程2，取出counter（eax = 0），加1（eax = 1），将counter存回原地址，此时counter的值为1。最后，再次时钟中断，线程1执行最后一条指令，将eax的值（eax = 1）存回原地址。

上述情况中，两个线程各执行了一次，但最后counte的值只加了1。这段代码被称为**临界区**，是访问共享变量的代码片段，一定不能由多个线程同时执行。

为了解决上述问题，我们需要硬件和操作系统的支持，提供一些指令，构建出互斥、公平、高性能的**锁**，保证在每个时刻只有一个线程访问临界区。

锁的原理并不复杂，实现方法多样，但使用不当很容易出现死锁等棘手问题。

